# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['LegacyJobArgs', 'LegacyJob']

@pulumi.input_type
class LegacyJobArgs:
    def __init__(__self__, *,
                 environment_id: pulumi.Input[int],
                 execute_steps: pulumi.Input[Sequence[pulumi.Input[str]]],
                 project_id: pulumi.Input[int],
                 triggers: pulumi.Input[Mapping[str, pulumi.Input[bool]]],
                 dbt_version: Optional[pulumi.Input[str]] = None,
                 deferring_environment_id: Optional[pulumi.Input[int]] = None,
                 deferring_job_id: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 generate_docs: Optional[pulumi.Input[bool]] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 job_completion_trigger_condition: Optional[pulumi.Input['LegacyJobJobCompletionTriggerConditionArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_threads: Optional[pulumi.Input[int]] = None,
                 run_generate_sources: Optional[pulumi.Input[bool]] = None,
                 schedule_cron: Optional[pulumi.Input[str]] = None,
                 schedule_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 schedule_hours: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 schedule_interval: Optional[pulumi.Input[int]] = None,
                 schedule_type: Optional[pulumi.Input[str]] = None,
                 self_deferring: Optional[pulumi.Input[bool]] = None,
                 target_name: Optional[pulumi.Input[str]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None,
                 triggers_on_draft_pr: Optional[pulumi.Input[bool]] = None):
        """
        The set of arguments for constructing a LegacyJob resource.
        :param pulumi.Input[int] environment_id: Environment ID to create the job in
        :param pulumi.Input[Sequence[pulumi.Input[str]]] execute_steps: List of commands to execute for the job
        :param pulumi.Input[int] project_id: Project ID to create the job in
        :param pulumi.Input[Mapping[str, pulumi.Input[bool]]] triggers: Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and
               `custom_branch_only`. <br>`custom_branch_only` is only relevant for CI jobs triggered automatically on PR creation to
               only trigger a job on a PR to the custom branch of the environment. To create a job in a 'deactivated' state, set all to
               `false`.
        :param pulumi.Input[str] dbt_version: Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions
        :param pulumi.Input[int] deferring_environment_id: Environment identifier that this job defers to (new deferring approach)
        :param pulumi.Input[int] deferring_job_id: Job identifier that this job defers to (legacy deferring approach)
        :param pulumi.Input[str] description: Description for the job
        :param pulumi.Input[bool] generate_docs: Flag for whether the job should generate documentation
        :param pulumi.Input[bool] is_active: Flag for whether the job is marked active or deleted. To create/keep a job in a 'deactivated' state, check the
               `triggers` config.
        :param pulumi.Input['LegacyJobJobCompletionTriggerConditionArgs'] job_completion_trigger_condition: Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job
               chaining').
        :param pulumi.Input[str] name: Job name
        :param pulumi.Input[int] num_threads: Number of threads to use in the job
        :param pulumi.Input[bool] run_generate_sources: Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a
               step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will
               still allow the following steps to run.
        :param pulumi.Input[str] schedule_cron: Custom cron expression for schedule
        :param pulumi.Input[Sequence[pulumi.Input[int]]] schedule_days: List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule
        :param pulumi.Input[Sequence[pulumi.Input[int]]] schedule_hours: List of hours to execute the job at if running on a schedule
        :param pulumi.Input[int] schedule_interval: Number of hours between job executions if running on a schedule
        :param pulumi.Input[str] schedule_type: Type of schedule to use, one of every_day/ days_of_week/ custom_cron
        :param pulumi.Input[bool] self_deferring: Whether this job defers on a previous run of itself
        :param pulumi.Input[str] target_name: Target name for the dbt profile
        :param pulumi.Input[int] timeout_seconds: Number of seconds to allow the job to run before timing out
        :param pulumi.Input[bool] triggers_on_draft_pr: Whether the CI job should be automatically triggered on draft PRs
        """
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "execute_steps", execute_steps)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "triggers", triggers)
        if dbt_version is not None:
            pulumi.set(__self__, "dbt_version", dbt_version)
        if deferring_environment_id is not None:
            pulumi.set(__self__, "deferring_environment_id", deferring_environment_id)
        if deferring_job_id is not None:
            pulumi.set(__self__, "deferring_job_id", deferring_job_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if generate_docs is not None:
            pulumi.set(__self__, "generate_docs", generate_docs)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if job_completion_trigger_condition is not None:
            pulumi.set(__self__, "job_completion_trigger_condition", job_completion_trigger_condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_threads is not None:
            pulumi.set(__self__, "num_threads", num_threads)
        if run_generate_sources is not None:
            pulumi.set(__self__, "run_generate_sources", run_generate_sources)
        if schedule_cron is not None:
            pulumi.set(__self__, "schedule_cron", schedule_cron)
        if schedule_days is not None:
            pulumi.set(__self__, "schedule_days", schedule_days)
        if schedule_hours is not None:
            pulumi.set(__self__, "schedule_hours", schedule_hours)
        if schedule_interval is not None:
            pulumi.set(__self__, "schedule_interval", schedule_interval)
        if schedule_type is not None:
            pulumi.set(__self__, "schedule_type", schedule_type)
        if self_deferring is not None:
            pulumi.set(__self__, "self_deferring", self_deferring)
        if target_name is not None:
            pulumi.set(__self__, "target_name", target_name)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if triggers_on_draft_pr is not None:
            pulumi.set(__self__, "triggers_on_draft_pr", triggers_on_draft_pr)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> pulumi.Input[int]:
        """
        Environment ID to create the job in
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "environment_id", value)

    @property
    @pulumi.getter(name="executeSteps")
    def execute_steps(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of commands to execute for the job
        """
        return pulumi.get(self, "execute_steps")

    @execute_steps.setter
    def execute_steps(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "execute_steps", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[int]:
        """
        Project ID to create the job in
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def triggers(self) -> pulumi.Input[Mapping[str, pulumi.Input[bool]]]:
        """
        Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and
        `custom_branch_only`. <br>`custom_branch_only` is only relevant for CI jobs triggered automatically on PR creation to
        only trigger a job on a PR to the custom branch of the environment. To create a job in a 'deactivated' state, set all to
        `false`.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: pulumi.Input[Mapping[str, pulumi.Input[bool]]]):
        pulumi.set(self, "triggers", value)

    @property
    @pulumi.getter(name="dbtVersion")
    def dbt_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions
        """
        return pulumi.get(self, "dbt_version")

    @dbt_version.setter
    def dbt_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbt_version", value)

    @property
    @pulumi.getter(name="deferringEnvironmentId")
    def deferring_environment_id(self) -> Optional[pulumi.Input[int]]:
        """
        Environment identifier that this job defers to (new deferring approach)
        """
        return pulumi.get(self, "deferring_environment_id")

    @deferring_environment_id.setter
    def deferring_environment_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "deferring_environment_id", value)

    @property
    @pulumi.getter(name="deferringJobId")
    def deferring_job_id(self) -> Optional[pulumi.Input[int]]:
        """
        Job identifier that this job defers to (legacy deferring approach)
        """
        return pulumi.get(self, "deferring_job_id")

    @deferring_job_id.setter
    def deferring_job_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "deferring_job_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description for the job
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="generateDocs")
    def generate_docs(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for whether the job should generate documentation
        """
        return pulumi.get(self, "generate_docs")

    @generate_docs.setter
    def generate_docs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_docs", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for whether the job is marked active or deleted. To create/keep a job in a 'deactivated' state, check the
        `triggers` config.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="jobCompletionTriggerCondition")
    def job_completion_trigger_condition(self) -> Optional[pulumi.Input['LegacyJobJobCompletionTriggerConditionArgs']]:
        """
        Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job
        chaining').
        """
        return pulumi.get(self, "job_completion_trigger_condition")

    @job_completion_trigger_condition.setter
    def job_completion_trigger_condition(self, value: Optional[pulumi.Input['LegacyJobJobCompletionTriggerConditionArgs']]):
        pulumi.set(self, "job_completion_trigger_condition", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Job name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numThreads")
    def num_threads(self) -> Optional[pulumi.Input[int]]:
        """
        Number of threads to use in the job
        """
        return pulumi.get(self, "num_threads")

    @num_threads.setter
    def num_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_threads", value)

    @property
    @pulumi.getter(name="runGenerateSources")
    def run_generate_sources(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a
        step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will
        still allow the following steps to run.
        """
        return pulumi.get(self, "run_generate_sources")

    @run_generate_sources.setter
    def run_generate_sources(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_generate_sources", value)

    @property
    @pulumi.getter(name="scheduleCron")
    def schedule_cron(self) -> Optional[pulumi.Input[str]]:
        """
        Custom cron expression for schedule
        """
        return pulumi.get(self, "schedule_cron")

    @schedule_cron.setter
    def schedule_cron(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_cron", value)

    @property
    @pulumi.getter(name="scheduleDays")
    def schedule_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule
        """
        return pulumi.get(self, "schedule_days")

    @schedule_days.setter
    def schedule_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "schedule_days", value)

    @property
    @pulumi.getter(name="scheduleHours")
    def schedule_hours(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of hours to execute the job at if running on a schedule
        """
        return pulumi.get(self, "schedule_hours")

    @schedule_hours.setter
    def schedule_hours(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "schedule_hours", value)

    @property
    @pulumi.getter(name="scheduleInterval")
    def schedule_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Number of hours between job executions if running on a schedule
        """
        return pulumi.get(self, "schedule_interval")

    @schedule_interval.setter
    def schedule_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "schedule_interval", value)

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of schedule to use, one of every_day/ days_of_week/ custom_cron
        """
        return pulumi.get(self, "schedule_type")

    @schedule_type.setter
    def schedule_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_type", value)

    @property
    @pulumi.getter(name="selfDeferring")
    def self_deferring(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this job defers on a previous run of itself
        """
        return pulumi.get(self, "self_deferring")

    @self_deferring.setter
    def self_deferring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "self_deferring", value)

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> Optional[pulumi.Input[str]]:
        """
        Target name for the dbt profile
        """
        return pulumi.get(self, "target_name")

    @target_name.setter
    def target_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_name", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to allow the job to run before timing out
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter(name="triggersOnDraftPr")
    def triggers_on_draft_pr(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the CI job should be automatically triggered on draft PRs
        """
        return pulumi.get(self, "triggers_on_draft_pr")

    @triggers_on_draft_pr.setter
    def triggers_on_draft_pr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "triggers_on_draft_pr", value)


@pulumi.input_type
class _LegacyJobState:
    def __init__(__self__, *,
                 dbt_version: Optional[pulumi.Input[str]] = None,
                 deferring_environment_id: Optional[pulumi.Input[int]] = None,
                 deferring_job_id: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 environment_id: Optional[pulumi.Input[int]] = None,
                 execute_steps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 generate_docs: Optional[pulumi.Input[bool]] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 job_completion_trigger_condition: Optional[pulumi.Input['LegacyJobJobCompletionTriggerConditionArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_threads: Optional[pulumi.Input[int]] = None,
                 project_id: Optional[pulumi.Input[int]] = None,
                 run_generate_sources: Optional[pulumi.Input[bool]] = None,
                 schedule_cron: Optional[pulumi.Input[str]] = None,
                 schedule_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 schedule_hours: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 schedule_interval: Optional[pulumi.Input[int]] = None,
                 schedule_type: Optional[pulumi.Input[str]] = None,
                 self_deferring: Optional[pulumi.Input[bool]] = None,
                 target_name: Optional[pulumi.Input[str]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None,
                 triggers: Optional[pulumi.Input[Mapping[str, pulumi.Input[bool]]]] = None,
                 triggers_on_draft_pr: Optional[pulumi.Input[bool]] = None):
        """
        Input properties used for looking up and filtering LegacyJob resources.
        :param pulumi.Input[str] dbt_version: Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions
        :param pulumi.Input[int] deferring_environment_id: Environment identifier that this job defers to (new deferring approach)
        :param pulumi.Input[int] deferring_job_id: Job identifier that this job defers to (legacy deferring approach)
        :param pulumi.Input[str] description: Description for the job
        :param pulumi.Input[int] environment_id: Environment ID to create the job in
        :param pulumi.Input[Sequence[pulumi.Input[str]]] execute_steps: List of commands to execute for the job
        :param pulumi.Input[bool] generate_docs: Flag for whether the job should generate documentation
        :param pulumi.Input[bool] is_active: Flag for whether the job is marked active or deleted. To create/keep a job in a 'deactivated' state, check the
               `triggers` config.
        :param pulumi.Input['LegacyJobJobCompletionTriggerConditionArgs'] job_completion_trigger_condition: Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job
               chaining').
        :param pulumi.Input[str] name: Job name
        :param pulumi.Input[int] num_threads: Number of threads to use in the job
        :param pulumi.Input[int] project_id: Project ID to create the job in
        :param pulumi.Input[bool] run_generate_sources: Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a
               step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will
               still allow the following steps to run.
        :param pulumi.Input[str] schedule_cron: Custom cron expression for schedule
        :param pulumi.Input[Sequence[pulumi.Input[int]]] schedule_days: List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule
        :param pulumi.Input[Sequence[pulumi.Input[int]]] schedule_hours: List of hours to execute the job at if running on a schedule
        :param pulumi.Input[int] schedule_interval: Number of hours between job executions if running on a schedule
        :param pulumi.Input[str] schedule_type: Type of schedule to use, one of every_day/ days_of_week/ custom_cron
        :param pulumi.Input[bool] self_deferring: Whether this job defers on a previous run of itself
        :param pulumi.Input[str] target_name: Target name for the dbt profile
        :param pulumi.Input[int] timeout_seconds: Number of seconds to allow the job to run before timing out
        :param pulumi.Input[Mapping[str, pulumi.Input[bool]]] triggers: Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and
               `custom_branch_only`. <br>`custom_branch_only` is only relevant for CI jobs triggered automatically on PR creation to
               only trigger a job on a PR to the custom branch of the environment. To create a job in a 'deactivated' state, set all to
               `false`.
        :param pulumi.Input[bool] triggers_on_draft_pr: Whether the CI job should be automatically triggered on draft PRs
        """
        if dbt_version is not None:
            pulumi.set(__self__, "dbt_version", dbt_version)
        if deferring_environment_id is not None:
            pulumi.set(__self__, "deferring_environment_id", deferring_environment_id)
        if deferring_job_id is not None:
            pulumi.set(__self__, "deferring_job_id", deferring_job_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if execute_steps is not None:
            pulumi.set(__self__, "execute_steps", execute_steps)
        if generate_docs is not None:
            pulumi.set(__self__, "generate_docs", generate_docs)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if job_completion_trigger_condition is not None:
            pulumi.set(__self__, "job_completion_trigger_condition", job_completion_trigger_condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_threads is not None:
            pulumi.set(__self__, "num_threads", num_threads)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if run_generate_sources is not None:
            pulumi.set(__self__, "run_generate_sources", run_generate_sources)
        if schedule_cron is not None:
            pulumi.set(__self__, "schedule_cron", schedule_cron)
        if schedule_days is not None:
            pulumi.set(__self__, "schedule_days", schedule_days)
        if schedule_hours is not None:
            pulumi.set(__self__, "schedule_hours", schedule_hours)
        if schedule_interval is not None:
            pulumi.set(__self__, "schedule_interval", schedule_interval)
        if schedule_type is not None:
            pulumi.set(__self__, "schedule_type", schedule_type)
        if self_deferring is not None:
            pulumi.set(__self__, "self_deferring", self_deferring)
        if target_name is not None:
            pulumi.set(__self__, "target_name", target_name)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)
        if triggers_on_draft_pr is not None:
            pulumi.set(__self__, "triggers_on_draft_pr", triggers_on_draft_pr)

    @property
    @pulumi.getter(name="dbtVersion")
    def dbt_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions
        """
        return pulumi.get(self, "dbt_version")

    @dbt_version.setter
    def dbt_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbt_version", value)

    @property
    @pulumi.getter(name="deferringEnvironmentId")
    def deferring_environment_id(self) -> Optional[pulumi.Input[int]]:
        """
        Environment identifier that this job defers to (new deferring approach)
        """
        return pulumi.get(self, "deferring_environment_id")

    @deferring_environment_id.setter
    def deferring_environment_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "deferring_environment_id", value)

    @property
    @pulumi.getter(name="deferringJobId")
    def deferring_job_id(self) -> Optional[pulumi.Input[int]]:
        """
        Job identifier that this job defers to (legacy deferring approach)
        """
        return pulumi.get(self, "deferring_job_id")

    @deferring_job_id.setter
    def deferring_job_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "deferring_job_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description for the job
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[pulumi.Input[int]]:
        """
        Environment ID to create the job in
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "environment_id", value)

    @property
    @pulumi.getter(name="executeSteps")
    def execute_steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of commands to execute for the job
        """
        return pulumi.get(self, "execute_steps")

    @execute_steps.setter
    def execute_steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "execute_steps", value)

    @property
    @pulumi.getter(name="generateDocs")
    def generate_docs(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for whether the job should generate documentation
        """
        return pulumi.get(self, "generate_docs")

    @generate_docs.setter
    def generate_docs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_docs", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for whether the job is marked active or deleted. To create/keep a job in a 'deactivated' state, check the
        `triggers` config.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="jobCompletionTriggerCondition")
    def job_completion_trigger_condition(self) -> Optional[pulumi.Input['LegacyJobJobCompletionTriggerConditionArgs']]:
        """
        Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job
        chaining').
        """
        return pulumi.get(self, "job_completion_trigger_condition")

    @job_completion_trigger_condition.setter
    def job_completion_trigger_condition(self, value: Optional[pulumi.Input['LegacyJobJobCompletionTriggerConditionArgs']]):
        pulumi.set(self, "job_completion_trigger_condition", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Job name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numThreads")
    def num_threads(self) -> Optional[pulumi.Input[int]]:
        """
        Number of threads to use in the job
        """
        return pulumi.get(self, "num_threads")

    @num_threads.setter
    def num_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_threads", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[int]]:
        """
        Project ID to create the job in
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="runGenerateSources")
    def run_generate_sources(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a
        step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will
        still allow the following steps to run.
        """
        return pulumi.get(self, "run_generate_sources")

    @run_generate_sources.setter
    def run_generate_sources(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_generate_sources", value)

    @property
    @pulumi.getter(name="scheduleCron")
    def schedule_cron(self) -> Optional[pulumi.Input[str]]:
        """
        Custom cron expression for schedule
        """
        return pulumi.get(self, "schedule_cron")

    @schedule_cron.setter
    def schedule_cron(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_cron", value)

    @property
    @pulumi.getter(name="scheduleDays")
    def schedule_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule
        """
        return pulumi.get(self, "schedule_days")

    @schedule_days.setter
    def schedule_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "schedule_days", value)

    @property
    @pulumi.getter(name="scheduleHours")
    def schedule_hours(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of hours to execute the job at if running on a schedule
        """
        return pulumi.get(self, "schedule_hours")

    @schedule_hours.setter
    def schedule_hours(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "schedule_hours", value)

    @property
    @pulumi.getter(name="scheduleInterval")
    def schedule_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Number of hours between job executions if running on a schedule
        """
        return pulumi.get(self, "schedule_interval")

    @schedule_interval.setter
    def schedule_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "schedule_interval", value)

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of schedule to use, one of every_day/ days_of_week/ custom_cron
        """
        return pulumi.get(self, "schedule_type")

    @schedule_type.setter
    def schedule_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_type", value)

    @property
    @pulumi.getter(name="selfDeferring")
    def self_deferring(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this job defers on a previous run of itself
        """
        return pulumi.get(self, "self_deferring")

    @self_deferring.setter
    def self_deferring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "self_deferring", value)

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> Optional[pulumi.Input[str]]:
        """
        Target name for the dbt profile
        """
        return pulumi.get(self, "target_name")

    @target_name.setter
    def target_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_name", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds to allow the job to run before timing out
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter
    def triggers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[bool]]]]:
        """
        Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and
        `custom_branch_only`. <br>`custom_branch_only` is only relevant for CI jobs triggered automatically on PR creation to
        only trigger a job on a PR to the custom branch of the environment. To create a job in a 'deactivated' state, set all to
        `false`.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[bool]]]]):
        pulumi.set(self, "triggers", value)

    @property
    @pulumi.getter(name="triggersOnDraftPr")
    def triggers_on_draft_pr(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the CI job should be automatically triggered on draft PRs
        """
        return pulumi.get(self, "triggers_on_draft_pr")

    @triggers_on_draft_pr.setter
    def triggers_on_draft_pr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "triggers_on_draft_pr", value)


warnings.warn("""Do not use! This resource is mapped from the legacy Terraform `dbt_cloud_`-prefixed resource/datasource""", DeprecationWarning)


class LegacyJob(pulumi.CustomResource):
    warnings.warn("""Do not use! This resource is mapped from the legacy Terraform `dbt_cloud_`-prefixed resource/datasource""", DeprecationWarning)

    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 dbt_version: Optional[pulumi.Input[str]] = None,
                 deferring_environment_id: Optional[pulumi.Input[int]] = None,
                 deferring_job_id: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 environment_id: Optional[pulumi.Input[int]] = None,
                 execute_steps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 generate_docs: Optional[pulumi.Input[bool]] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 job_completion_trigger_condition: Optional[pulumi.Input[pulumi.InputType['LegacyJobJobCompletionTriggerConditionArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_threads: Optional[pulumi.Input[int]] = None,
                 project_id: Optional[pulumi.Input[int]] = None,
                 run_generate_sources: Optional[pulumi.Input[bool]] = None,
                 schedule_cron: Optional[pulumi.Input[str]] = None,
                 schedule_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 schedule_hours: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 schedule_interval: Optional[pulumi.Input[int]] = None,
                 schedule_type: Optional[pulumi.Input[str]] = None,
                 self_deferring: Optional[pulumi.Input[bool]] = None,
                 target_name: Optional[pulumi.Input[str]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None,
                 triggers: Optional[pulumi.Input[Mapping[str, pulumi.Input[bool]]]] = None,
                 triggers_on_draft_pr: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        """
        Create a LegacyJob resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] dbt_version: Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions
        :param pulumi.Input[int] deferring_environment_id: Environment identifier that this job defers to (new deferring approach)
        :param pulumi.Input[int] deferring_job_id: Job identifier that this job defers to (legacy deferring approach)
        :param pulumi.Input[str] description: Description for the job
        :param pulumi.Input[int] environment_id: Environment ID to create the job in
        :param pulumi.Input[Sequence[pulumi.Input[str]]] execute_steps: List of commands to execute for the job
        :param pulumi.Input[bool] generate_docs: Flag for whether the job should generate documentation
        :param pulumi.Input[bool] is_active: Flag for whether the job is marked active or deleted. To create/keep a job in a 'deactivated' state, check the
               `triggers` config.
        :param pulumi.Input[pulumi.InputType['LegacyJobJobCompletionTriggerConditionArgs']] job_completion_trigger_condition: Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job
               chaining').
        :param pulumi.Input[str] name: Job name
        :param pulumi.Input[int] num_threads: Number of threads to use in the job
        :param pulumi.Input[int] project_id: Project ID to create the job in
        :param pulumi.Input[bool] run_generate_sources: Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a
               step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will
               still allow the following steps to run.
        :param pulumi.Input[str] schedule_cron: Custom cron expression for schedule
        :param pulumi.Input[Sequence[pulumi.Input[int]]] schedule_days: List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule
        :param pulumi.Input[Sequence[pulumi.Input[int]]] schedule_hours: List of hours to execute the job at if running on a schedule
        :param pulumi.Input[int] schedule_interval: Number of hours between job executions if running on a schedule
        :param pulumi.Input[str] schedule_type: Type of schedule to use, one of every_day/ days_of_week/ custom_cron
        :param pulumi.Input[bool] self_deferring: Whether this job defers on a previous run of itself
        :param pulumi.Input[str] target_name: Target name for the dbt profile
        :param pulumi.Input[int] timeout_seconds: Number of seconds to allow the job to run before timing out
        :param pulumi.Input[Mapping[str, pulumi.Input[bool]]] triggers: Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and
               `custom_branch_only`. <br>`custom_branch_only` is only relevant for CI jobs triggered automatically on PR creation to
               only trigger a job on a PR to the custom branch of the environment. To create a job in a 'deactivated' state, set all to
               `false`.
        :param pulumi.Input[bool] triggers_on_draft_pr: Whether the CI job should be automatically triggered on draft PRs
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: LegacyJobArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Create a LegacyJob resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param LegacyJobArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(LegacyJobArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 dbt_version: Optional[pulumi.Input[str]] = None,
                 deferring_environment_id: Optional[pulumi.Input[int]] = None,
                 deferring_job_id: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 environment_id: Optional[pulumi.Input[int]] = None,
                 execute_steps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 generate_docs: Optional[pulumi.Input[bool]] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 job_completion_trigger_condition: Optional[pulumi.Input[pulumi.InputType['LegacyJobJobCompletionTriggerConditionArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_threads: Optional[pulumi.Input[int]] = None,
                 project_id: Optional[pulumi.Input[int]] = None,
                 run_generate_sources: Optional[pulumi.Input[bool]] = None,
                 schedule_cron: Optional[pulumi.Input[str]] = None,
                 schedule_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 schedule_hours: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 schedule_interval: Optional[pulumi.Input[int]] = None,
                 schedule_type: Optional[pulumi.Input[str]] = None,
                 self_deferring: Optional[pulumi.Input[bool]] = None,
                 target_name: Optional[pulumi.Input[str]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None,
                 triggers: Optional[pulumi.Input[Mapping[str, pulumi.Input[bool]]]] = None,
                 triggers_on_draft_pr: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        pulumi.log.warn("""LegacyJob is deprecated: Do not use! This resource is mapped from the legacy Terraform `dbt_cloud_`-prefixed resource/datasource""")
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = LegacyJobArgs.__new__(LegacyJobArgs)

            __props__.__dict__["dbt_version"] = dbt_version
            __props__.__dict__["deferring_environment_id"] = deferring_environment_id
            __props__.__dict__["deferring_job_id"] = deferring_job_id
            __props__.__dict__["description"] = description
            if environment_id is None and not opts.urn:
                raise TypeError("Missing required property 'environment_id'")
            __props__.__dict__["environment_id"] = environment_id
            if execute_steps is None and not opts.urn:
                raise TypeError("Missing required property 'execute_steps'")
            __props__.__dict__["execute_steps"] = execute_steps
            __props__.__dict__["generate_docs"] = generate_docs
            __props__.__dict__["is_active"] = is_active
            __props__.__dict__["job_completion_trigger_condition"] = job_completion_trigger_condition
            __props__.__dict__["name"] = name
            __props__.__dict__["num_threads"] = num_threads
            if project_id is None and not opts.urn:
                raise TypeError("Missing required property 'project_id'")
            __props__.__dict__["project_id"] = project_id
            __props__.__dict__["run_generate_sources"] = run_generate_sources
            __props__.__dict__["schedule_cron"] = schedule_cron
            __props__.__dict__["schedule_days"] = schedule_days
            __props__.__dict__["schedule_hours"] = schedule_hours
            __props__.__dict__["schedule_interval"] = schedule_interval
            __props__.__dict__["schedule_type"] = schedule_type
            __props__.__dict__["self_deferring"] = self_deferring
            __props__.__dict__["target_name"] = target_name
            __props__.__dict__["timeout_seconds"] = timeout_seconds
            if triggers is None and not opts.urn:
                raise TypeError("Missing required property 'triggers'")
            __props__.__dict__["triggers"] = triggers
            __props__.__dict__["triggers_on_draft_pr"] = triggers_on_draft_pr
        super(LegacyJob, __self__).__init__(
            'dbtcloud:index/legacyJob:LegacyJob',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            dbt_version: Optional[pulumi.Input[str]] = None,
            deferring_environment_id: Optional[pulumi.Input[int]] = None,
            deferring_job_id: Optional[pulumi.Input[int]] = None,
            description: Optional[pulumi.Input[str]] = None,
            environment_id: Optional[pulumi.Input[int]] = None,
            execute_steps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            generate_docs: Optional[pulumi.Input[bool]] = None,
            is_active: Optional[pulumi.Input[bool]] = None,
            job_completion_trigger_condition: Optional[pulumi.Input[pulumi.InputType['LegacyJobJobCompletionTriggerConditionArgs']]] = None,
            name: Optional[pulumi.Input[str]] = None,
            num_threads: Optional[pulumi.Input[int]] = None,
            project_id: Optional[pulumi.Input[int]] = None,
            run_generate_sources: Optional[pulumi.Input[bool]] = None,
            schedule_cron: Optional[pulumi.Input[str]] = None,
            schedule_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
            schedule_hours: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
            schedule_interval: Optional[pulumi.Input[int]] = None,
            schedule_type: Optional[pulumi.Input[str]] = None,
            self_deferring: Optional[pulumi.Input[bool]] = None,
            target_name: Optional[pulumi.Input[str]] = None,
            timeout_seconds: Optional[pulumi.Input[int]] = None,
            triggers: Optional[pulumi.Input[Mapping[str, pulumi.Input[bool]]]] = None,
            triggers_on_draft_pr: Optional[pulumi.Input[bool]] = None) -> 'LegacyJob':
        """
        Get an existing LegacyJob resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] dbt_version: Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions
        :param pulumi.Input[int] deferring_environment_id: Environment identifier that this job defers to (new deferring approach)
        :param pulumi.Input[int] deferring_job_id: Job identifier that this job defers to (legacy deferring approach)
        :param pulumi.Input[str] description: Description for the job
        :param pulumi.Input[int] environment_id: Environment ID to create the job in
        :param pulumi.Input[Sequence[pulumi.Input[str]]] execute_steps: List of commands to execute for the job
        :param pulumi.Input[bool] generate_docs: Flag for whether the job should generate documentation
        :param pulumi.Input[bool] is_active: Flag for whether the job is marked active or deleted. To create/keep a job in a 'deactivated' state, check the
               `triggers` config.
        :param pulumi.Input[pulumi.InputType['LegacyJobJobCompletionTriggerConditionArgs']] job_completion_trigger_condition: Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job
               chaining').
        :param pulumi.Input[str] name: Job name
        :param pulumi.Input[int] num_threads: Number of threads to use in the job
        :param pulumi.Input[int] project_id: Project ID to create the job in
        :param pulumi.Input[bool] run_generate_sources: Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a
               step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will
               still allow the following steps to run.
        :param pulumi.Input[str] schedule_cron: Custom cron expression for schedule
        :param pulumi.Input[Sequence[pulumi.Input[int]]] schedule_days: List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule
        :param pulumi.Input[Sequence[pulumi.Input[int]]] schedule_hours: List of hours to execute the job at if running on a schedule
        :param pulumi.Input[int] schedule_interval: Number of hours between job executions if running on a schedule
        :param pulumi.Input[str] schedule_type: Type of schedule to use, one of every_day/ days_of_week/ custom_cron
        :param pulumi.Input[bool] self_deferring: Whether this job defers on a previous run of itself
        :param pulumi.Input[str] target_name: Target name for the dbt profile
        :param pulumi.Input[int] timeout_seconds: Number of seconds to allow the job to run before timing out
        :param pulumi.Input[Mapping[str, pulumi.Input[bool]]] triggers: Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and
               `custom_branch_only`. <br>`custom_branch_only` is only relevant for CI jobs triggered automatically on PR creation to
               only trigger a job on a PR to the custom branch of the environment. To create a job in a 'deactivated' state, set all to
               `false`.
        :param pulumi.Input[bool] triggers_on_draft_pr: Whether the CI job should be automatically triggered on draft PRs
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _LegacyJobState.__new__(_LegacyJobState)

        __props__.__dict__["dbt_version"] = dbt_version
        __props__.__dict__["deferring_environment_id"] = deferring_environment_id
        __props__.__dict__["deferring_job_id"] = deferring_job_id
        __props__.__dict__["description"] = description
        __props__.__dict__["environment_id"] = environment_id
        __props__.__dict__["execute_steps"] = execute_steps
        __props__.__dict__["generate_docs"] = generate_docs
        __props__.__dict__["is_active"] = is_active
        __props__.__dict__["job_completion_trigger_condition"] = job_completion_trigger_condition
        __props__.__dict__["name"] = name
        __props__.__dict__["num_threads"] = num_threads
        __props__.__dict__["project_id"] = project_id
        __props__.__dict__["run_generate_sources"] = run_generate_sources
        __props__.__dict__["schedule_cron"] = schedule_cron
        __props__.__dict__["schedule_days"] = schedule_days
        __props__.__dict__["schedule_hours"] = schedule_hours
        __props__.__dict__["schedule_interval"] = schedule_interval
        __props__.__dict__["schedule_type"] = schedule_type
        __props__.__dict__["self_deferring"] = self_deferring
        __props__.__dict__["target_name"] = target_name
        __props__.__dict__["timeout_seconds"] = timeout_seconds
        __props__.__dict__["triggers"] = triggers
        __props__.__dict__["triggers_on_draft_pr"] = triggers_on_draft_pr
        return LegacyJob(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="dbtVersion")
    def dbt_version(self) -> pulumi.Output[Optional[str]]:
        """
        Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions
        """
        return pulumi.get(self, "dbt_version")

    @property
    @pulumi.getter(name="deferringEnvironmentId")
    def deferring_environment_id(self) -> pulumi.Output[Optional[int]]:
        """
        Environment identifier that this job defers to (new deferring approach)
        """
        return pulumi.get(self, "deferring_environment_id")

    @property
    @pulumi.getter(name="deferringJobId")
    def deferring_job_id(self) -> pulumi.Output[Optional[int]]:
        """
        Job identifier that this job defers to (legacy deferring approach)
        """
        return pulumi.get(self, "deferring_job_id")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[str]]:
        """
        Description for the job
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> pulumi.Output[int]:
        """
        Environment ID to create the job in
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="executeSteps")
    def execute_steps(self) -> pulumi.Output[Sequence[str]]:
        """
        List of commands to execute for the job
        """
        return pulumi.get(self, "execute_steps")

    @property
    @pulumi.getter(name="generateDocs")
    def generate_docs(self) -> pulumi.Output[Optional[bool]]:
        """
        Flag for whether the job should generate documentation
        """
        return pulumi.get(self, "generate_docs")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> pulumi.Output[Optional[bool]]:
        """
        Flag for whether the job is marked active or deleted. To create/keep a job in a 'deactivated' state, check the
        `triggers` config.
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter(name="jobCompletionTriggerCondition")
    def job_completion_trigger_condition(self) -> pulumi.Output[Optional['outputs.LegacyJobJobCompletionTriggerCondition']]:
        """
        Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job
        chaining').
        """
        return pulumi.get(self, "job_completion_trigger_condition")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        Job name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numThreads")
    def num_threads(self) -> pulumi.Output[Optional[int]]:
        """
        Number of threads to use in the job
        """
        return pulumi.get(self, "num_threads")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Output[int]:
        """
        Project ID to create the job in
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="runGenerateSources")
    def run_generate_sources(self) -> pulumi.Output[Optional[bool]]:
        """
        Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a
        step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will
        still allow the following steps to run.
        """
        return pulumi.get(self, "run_generate_sources")

    @property
    @pulumi.getter(name="scheduleCron")
    def schedule_cron(self) -> pulumi.Output[Optional[str]]:
        """
        Custom cron expression for schedule
        """
        return pulumi.get(self, "schedule_cron")

    @property
    @pulumi.getter(name="scheduleDays")
    def schedule_days(self) -> pulumi.Output[Optional[Sequence[int]]]:
        """
        List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule
        """
        return pulumi.get(self, "schedule_days")

    @property
    @pulumi.getter(name="scheduleHours")
    def schedule_hours(self) -> pulumi.Output[Optional[Sequence[int]]]:
        """
        List of hours to execute the job at if running on a schedule
        """
        return pulumi.get(self, "schedule_hours")

    @property
    @pulumi.getter(name="scheduleInterval")
    def schedule_interval(self) -> pulumi.Output[Optional[int]]:
        """
        Number of hours between job executions if running on a schedule
        """
        return pulumi.get(self, "schedule_interval")

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> pulumi.Output[Optional[str]]:
        """
        Type of schedule to use, one of every_day/ days_of_week/ custom_cron
        """
        return pulumi.get(self, "schedule_type")

    @property
    @pulumi.getter(name="selfDeferring")
    def self_deferring(self) -> pulumi.Output[Optional[bool]]:
        """
        Whether this job defers on a previous run of itself
        """
        return pulumi.get(self, "self_deferring")

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> pulumi.Output[Optional[str]]:
        """
        Target name for the dbt profile
        """
        return pulumi.get(self, "target_name")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> pulumi.Output[Optional[int]]:
        """
        Number of seconds to allow the job to run before timing out
        """
        return pulumi.get(self, "timeout_seconds")

    @property
    @pulumi.getter
    def triggers(self) -> pulumi.Output[Mapping[str, bool]]:
        """
        Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and
        `custom_branch_only`. <br>`custom_branch_only` is only relevant for CI jobs triggered automatically on PR creation to
        only trigger a job on a PR to the custom branch of the environment. To create a job in a 'deactivated' state, set all to
        `false`.
        """
        return pulumi.get(self, "triggers")

    @property
    @pulumi.getter(name="triggersOnDraftPr")
    def triggers_on_draft_pr(self) -> pulumi.Output[Optional[bool]]:
        """
        Whether the CI job should be automatically triggered on draft PRs
        """
        return pulumi.get(self, "triggers_on_draft_pr")

